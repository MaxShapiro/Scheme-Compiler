
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

section .data
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_BOOL(0)
MAKE_BOOL(1)
MAKE_LITERAL_STRING "helloworld"
MAKE_LITERAL_INT(4)
MAKE_LITERAL_INT(1)
MAKE_LITERAL_STRING "char"
MAKE_LITERAL_SYMBOL(const_tbl+43)
MAKE_LITERAL_STRING "whatever"
MAKE_LITERAL_SYMBOL(const_tbl+65)
MAKE_LITERAL_INT(0)
MAKE_LITERAL_CHAR(0)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

fvar_tbl:
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED

global main
section .text
main:
    push rbp

    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp
    mov rbp,rsp


    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl+(0*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl+(1*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl+(2*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl+(3*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl+(4*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl+(5*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl+(6*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl+(7*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl+(8*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl+(9*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl+(10*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl+(11*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl+(12*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl+(13*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl+(14*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl+(15*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl+(16*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl+(17*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl+(18*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl+(19*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl+(20*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl+(21*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl+(22*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, proc_car)
    mov [fvar_tbl+(24*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, proc_cdr)
    mov [fvar_tbl+(25*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, proc_cons)
    mov [fvar_tbl+(23*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, proc_set_car)
    mov [fvar_tbl+(26*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, proc_set_cdr)
    mov [fvar_tbl+(27*8) ], rax
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, proc_apply)
    mov [fvar_tbl+(28*8) ], rax

user_code_fragment:
;;; The code you compiled will be catenated here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.

Gen_Def_Var_Free_1:
Gen_Applic_2:

push SOB_NIL_ADDRESS
Gen_Var_Free_3:
mov rax, qword [fvar_tbl+(28*8)]
end_Gen_Var_Free_3:

push rax
Gen_Var_Free_4:
mov rax, qword [fvar_tbl+(23*8)]
end_Gen_Var_Free_4:

push rax
Gen_Var_Free_5:
mov rax, qword [fvar_tbl+(25*8)]
end_Gen_Var_Free_5:

push rax
Gen_Var_Free_6:
mov rax, qword [fvar_tbl+(24*8)]
end_Gen_Var_Free_6:

push rax
Gen_Var_Free_7:
mov rax, qword [fvar_tbl+(4*8)]
end_Gen_Var_Free_7:

push rax

push 5
Gen_Lambda_Simple_8:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_13 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_9:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_9
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_10:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_10
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_13:
  MAKE_CLOSURE(rax, rbx, Lcode_11)
  jmp Lcont_12
  Lcode_11:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_14:

push SOB_NIL_ADDRESS
Gen_Const_15:
mov rax, const_tbl+82
end_Gen_Const_15:

push rax

push 1
Gen_Lambda_Simple_16:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_21 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_17:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_17
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_18:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_18
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_21:
  MAKE_CLOSURE(rax, rbx, Lcode_19)
  jmp Lcont_20
  Lcode_19:
    push rbp
    mov rbp, rsp
    Gen_Seq_22:
Gen_Set_Var_Param_23:
Gen_Box_24:
Gen_Var_Param_25:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_25:

MALLOC r10, 8
mov qword[r10], rax
mov rax, r10
end_Gen_Box_24:

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Set_Var_Param_23:

Gen_Seq_26:
Gen_Box_get_27:
Gen_Lambda_Opt_29:
; allocate ExtEnv to be of size |Env| + 1

  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9            ; for dummy frame

  cmp r9, 8                           ; if first lambda -> skip the old env copy
  mov qword[rbx], SOB_NIL_ADDRESS
  je first_lambda_36 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_32:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_32
  mov r8, 0
  mov rcx, PARAM_COUNT            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_33:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, PARAM_COUNT
  jle move_params_loop_33
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_36:
  MAKE_CLOSURE(rax, rbx, Lcode_34)
  jmp Lcont_35
  Lcode_34:
        push rbp
    mov rbp, rsp
    ;adjust the stack for the optional arguments
    mov rax, 3           ; num of params
    mov r15, qword[rbp + (8*3)]           ; num of args
    cmp rax, r15
    jg Opt_lable_37
    mov qword[rbp + (8*3)], rax           ; change num of args 
    ; make pairs
    mov r9, qword[rbp + 8*(3+r15)]        ; r9 holds last arg
    mov r10, SOB_NIL_ADDRESS              ; for the last pair
    mov r11, r15
    MAKE_PAIR(r8, r9, r10)                ; Pair(last_arg, NIL)
    loop_30: 
    cmp r11, rax                          ; if top = bottom, finish
    je finish_pairing_31 
    dec r11
    mov r10, qword[rbp + 8*(3 + r11)]
    mov r13, r8
    MAKE_PAIR(r8, r10, r13)
    jmp loop_30 
    finish_pairing_31:
    mov qword[rbp + 8*(3+rax)], r8          ; the last element is now a pair
  
    ; change the stack
    mov r9, rax
    mov r10, rax
    add r10, 4
    mov rdx, r15
    add rdx, 2
    _loop_30:
    cmp r10, 0
    je __loop_30
    dec r10
    dec rdx
    mov rcx, [rbp + r10*8]
    mov [rbp + 8*(2+rdx)], rcx
    jmp _loop_30       ; finised moving args
    
    __loop_30: 
    add rdx, 2
    shl rdx, 3
    add rsp, rdx
    mov rbp, rsp
    Opt_lable_37:
    Gen_If_38:
Gen_Applic_100:

push SOB_NIL_ADDRESS
Gen_Var_Param_101:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_101:

push rax

push 1
Gen_Var_Bound_102:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_102:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_103:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_100:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_39
Gen_Const_99:
mov rax, const_tbl+1
end_Gen_Const_99:

jmp Lexit_40
Lelse_39:
Gen_If_41:
Gen_Applic_95:

push SOB_NIL_ADDRESS
Gen_Var_Param_96:
 mov rax, qword[rbp + 8 * (4 + 2)]
end_Gen_Var_Param_96:

push rax

push 1
Gen_Var_Bound_97:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_97:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_98:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_95:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_42
Gen_ApplicTP_76:

push SOB_NIL_ADDRESS
Gen_Applic_77:

push SOB_NIL_ADDRESS
Gen_Applic_78:

push SOB_NIL_ADDRESS
Gen_Var_Param_79:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_79:

push rax

push 1
Gen_Var_Bound_80:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_80:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_81:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_78:

push rax
Gen_Var_Param_82:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_82:

push rax

push 2
Gen_Box_Get_83:
Gen_Var_Bound_84:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_84:

mov rax, qword [rax]
end_Gen_Box_Get_83:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_85:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_77:

push rax
Gen_Applic_86:

push SOB_NIL_ADDRESS
Gen_Applic_87:

push SOB_NIL_ADDRESS
Gen_Var_Param_88:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_88:

push rax

push 1
Gen_Var_Bound_89:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_89:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_90:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_87:

push rax

push 1
Gen_Var_Param_91:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_91:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_92:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_86:

push rax

push 2
Gen_Var_Bound_93:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 3)]
end_Gen_Var_Bound_93:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_94:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_76:

jmp Lexit_43
Lelse_42:
Gen_ApplicTP_44:

push SOB_NIL_ADDRESS
Gen_Applic_45:

push SOB_NIL_ADDRESS
Gen_Applic_46:

push SOB_NIL_ADDRESS
Gen_Var_Param_47:
 mov rax, qword[rbp + 8 * (4 + 2)]
end_Gen_Var_Param_47:

push rax
Gen_Var_Bound_48:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_48:

push rax

push 2
Gen_Box_Get_49:
Gen_Var_Bound_50:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_50:

mov rax, qword [rax]
end_Gen_Box_Get_49:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_51:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_46:

push rax
Gen_Applic_52:

push SOB_NIL_ADDRESS
Gen_Var_Param_53:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_53:

push rax

push 1
Gen_Var_Bound_54:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_54:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_55:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_52:

push rax
Gen_Var_Param_56:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_56:

push rax
Gen_Var_Free_57:
mov rax, qword [fvar_tbl+(29*8)]
end_Gen_Var_Free_57:

push rax

push 4
Gen_Var_Bound_58:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 4)]
end_Gen_Var_Bound_58:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_59:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_45:

push rax
Gen_Applic_60:

push SOB_NIL_ADDRESS
Gen_Applic_61:

push SOB_NIL_ADDRESS
Gen_Var_Param_62:
 mov rax, qword[rbp + 8 * (4 + 2)]
end_Gen_Var_Param_62:

push rax
Gen_Var_Bound_63:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_63:

push rax

push 2
Gen_Box_Get_64:
Gen_Var_Bound_65:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_65:

mov rax, qword [rax]
end_Gen_Box_Get_64:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_66:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_61:

push rax
Gen_Applic_67:

push SOB_NIL_ADDRESS
Gen_Var_Param_68:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_68:

push rax

push 1
Gen_Var_Bound_69:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_69:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_70:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_67:

push rax
Gen_Var_Param_71:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_71:

push rax

push 3
Gen_Var_Bound_72:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 4)]
end_Gen_Var_Bound_72:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_73:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_60:

push rax

push 2
Gen_Var_Bound_74:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 3)]
end_Gen_Var_Bound_74:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_75:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_44:

Lexit_43:
end_Gen_If_41:

Lexit_40:
end_Gen_If_38:

    leave
    ret
  Lcont_35:
  
end_Gen_Lambda_Opt_29:

push rax
Gen_Var_Param_28:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_28:

pop qword [rax]
mov rax, SOB_VOID_ADDRESS
end_Gen_Box_get_27:

Gen_Box_Get_104:
Gen_Var_Param_105:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_105:

mov rax, qword [rax]
end_Gen_Box_Get_104:

end_Gen_Seq_26:

end_Gen_Seq_22:

    leave
    ret
  Lcont_20:
  
end_Gen_Lambda_Simple_16:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_106:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 6                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_14:

    leave
    ret
  Lcont_12:
  
end_Gen_Lambda_Simple_8:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_107:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_2:

mov qword [fvar_tbl+(29*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_1:

	call write_sob_if_not_void

Gen_Def_Var_Free_108:
Gen_Lambda_Simple_109:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_114 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_110:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_110
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_111:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_111
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_114:
  MAKE_CLOSURE(rax, rbx, Lcode_112)
  jmp Lcont_113
  Lcode_112:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_115:

push SOB_NIL_ADDRESS
Gen_Var_Free_116:
mov rax, qword [fvar_tbl+(25*8)]
end_Gen_Var_Free_116:

push rax
Gen_Var_Free_117:
mov rax, qword [fvar_tbl+(24*8)]
end_Gen_Var_Free_117:

push rax
Gen_Var_Free_118:
mov rax, qword [fvar_tbl+(4*8)]
end_Gen_Var_Free_118:

push rax

push 3
Gen_Lambda_Simple_119:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_124 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_120:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_120
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_121:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_121
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_124:
  MAKE_CLOSURE(rax, rbx, Lcode_122)
  jmp Lcont_123
  Lcode_122:
    push rbp
    mov rbp, rsp
    Gen_If_125:
Gen_Applic_145:

push SOB_NIL_ADDRESS
Gen_Var_Bound_146:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_146:

push rax

push 1
Gen_Var_Param_147:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_147:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_148:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_145:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_126
Gen_Var_Bound_144:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_144:

jmp Lexit_127
Lelse_126:
Gen_ApplicTP_128:

push SOB_NIL_ADDRESS
Gen_Applic_129:

push SOB_NIL_ADDRESS
Gen_Var_Bound_130:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_130:

push rax

push 1
Gen_Var_Param_131:
 mov rax, qword[rbp + 8 * (4 + 2)]
end_Gen_Var_Param_131:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_132:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_129:

push rax
Gen_Applic_133:

push SOB_NIL_ADDRESS
Gen_Applic_134:

push SOB_NIL_ADDRESS
Gen_Var_Bound_135:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_135:

push rax

push 1
Gen_Var_Param_136:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_136:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_137:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_134:

push rax
Gen_Var_Bound_138:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_138:

push rax

push 2
Gen_Var_Bound_139:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_139:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_140:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_133:

push rax
Gen_Var_Bound_141:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_141:

push rax

push 3
Gen_Var_Free_142:
mov rax, qword [fvar_tbl+(30*8)]
end_Gen_Var_Free_142:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_143:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 8                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_128:

Lexit_127:
end_Gen_If_125:

    leave
    ret
  Lcont_123:
  
end_Gen_Lambda_Simple_119:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_149:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 8                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_115:

    leave
    ret
  Lcont_113:
  
end_Gen_Lambda_Simple_109:

mov qword [fvar_tbl+(30*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_108:

	call write_sob_if_not_void

Gen_Def_Var_Free_150:
Gen_Lambda_Simple_151:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_156 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_152:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_152
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_153:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_153
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_156:
  MAKE_CLOSURE(rax, rbx, Lcode_154)
  jmp Lcont_155
  Lcode_154:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_157:

push SOB_NIL_ADDRESS
Gen_Var_Free_158:
mov rax, qword [fvar_tbl+(25*8)]
end_Gen_Var_Free_158:

push rax
Gen_Var_Free_159:
mov rax, qword [fvar_tbl+(24*8)]
end_Gen_Var_Free_159:

push rax
Gen_Var_Free_160:
mov rax, qword [fvar_tbl+(4*8)]
end_Gen_Var_Free_160:

push rax

push 3
Gen_Lambda_Simple_161:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_166 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_162:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_162
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_163:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_163
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_166:
  MAKE_CLOSURE(rax, rbx, Lcode_164)
  jmp Lcont_165
  Lcode_164:
    push rbp
    mov rbp, rsp
    Gen_If_167:
Gen_Applic_187:

push SOB_NIL_ADDRESS
Gen_Var_Bound_188:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_188:

push rax

push 1
Gen_Var_Param_189:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_189:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_190:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_187:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_168
Gen_Var_Bound_186:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_186:

jmp Lexit_169
Lelse_168:
Gen_ApplicTP_170:

push SOB_NIL_ADDRESS
Gen_Applic_171:

push SOB_NIL_ADDRESS
Gen_Applic_172:

push SOB_NIL_ADDRESS
Gen_Var_Bound_173:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_173:

push rax

push 1
Gen_Var_Param_174:
 mov rax, qword[rbp + 8 * (4 + 2)]
end_Gen_Var_Param_174:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_175:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_172:

push rax
Gen_Var_Bound_176:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_176:

push rax
Gen_Var_Bound_177:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_177:

push rax

push 3
Gen_Var_Free_178:
mov rax, qword [fvar_tbl+(31*8)]
end_Gen_Var_Free_178:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_179:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_171:

push rax
Gen_Applic_180:

push SOB_NIL_ADDRESS
Gen_Var_Bound_181:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_181:

push rax

push 1
Gen_Var_Param_182:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_182:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_183:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_180:

push rax

push 2
Gen_Var_Bound_184:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_184:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_185:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_170:

Lexit_169:
end_Gen_If_167:

    leave
    ret
  Lcont_165:
  
end_Gen_Lambda_Simple_161:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_191:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 8                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_157:

    leave
    ret
  Lcont_155:
  
end_Gen_Lambda_Simple_151:

mov qword [fvar_tbl+(31*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_150:

	call write_sob_if_not_void

Gen_Def_Var_Free_192:
Gen_Applic_193:

push SOB_NIL_ADDRESS
Gen_Var_Free_194:
mov rax, qword [fvar_tbl+(23*8)]
end_Gen_Var_Free_194:

push rax
Gen_Var_Free_195:
mov rax, qword [fvar_tbl+(31*8)]
end_Gen_Var_Free_195:

push rax
Gen_Var_Free_196:
mov rax, qword [fvar_tbl+(4*8)]
end_Gen_Var_Free_196:

push rax

push 3
Gen_Lambda_Simple_197:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_202 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_198:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_198
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_199:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_199
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_202:
  MAKE_CLOSURE(rax, rbx, Lcode_200)
  jmp Lcont_201
  Lcode_200:
    push rbp
    mov rbp, rsp
    Gen_Lambda_Opt_203:
; allocate ExtEnv to be of size |Env| + 1

  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9            ; for dummy frame

  cmp r9, 8                           ; if first lambda -> skip the old env copy
  mov qword[rbx], SOB_NIL_ADDRESS
  je first_lambda_210 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_206:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_206
  mov r8, 0
  mov rcx, PARAM_COUNT            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_207:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, PARAM_COUNT
  jle move_params_loop_207
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_210:
  MAKE_CLOSURE(rax, rbx, Lcode_208)
  jmp Lcont_209
  Lcode_208:
        push rbp
    mov rbp, rsp
    ;adjust the stack for the optional arguments
    mov rax, 1           ; num of params
    mov r15, qword[rbp + (8*3)]           ; num of args
    cmp rax, r15
    jg Opt_lable_211
    mov qword[rbp + (8*3)], rax           ; change num of args 
    ; make pairs
    mov r9, qword[rbp + 8*(3+r15)]        ; r9 holds last arg
    mov r10, SOB_NIL_ADDRESS              ; for the last pair
    mov r11, r15
    MAKE_PAIR(r8, r9, r10)                ; Pair(last_arg, NIL)
    loop_204: 
    cmp r11, rax                          ; if top = bottom, finish
    je finish_pairing_205 
    dec r11
    mov r10, qword[rbp + 8*(3 + r11)]
    mov r13, r8
    MAKE_PAIR(r8, r10, r13)
    jmp loop_204 
    finish_pairing_205:
    mov qword[rbp + 8*(3+rax)], r8          ; the last element is now a pair
  
    ; change the stack
    mov r9, rax
    mov r10, rax
    add r10, 4
    mov rdx, r15
    add rdx, 2
    _loop_204:
    cmp r10, 0
    je __loop_204
    dec r10
    dec rdx
    mov rcx, [rbp + r10*8]
    mov [rbp + 8*(2+rdx)], rcx
    jmp _loop_204       ; finised moving args
    
    __loop_204: 
    add rdx, 2
    shl rdx, 3
    add rsp, rdx
    mov rbp, rsp
    Opt_lable_211:
    Gen_ApplicTP_212:

push SOB_NIL_ADDRESS
Gen_Var_Param_213:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_213:

push rax
Gen_Const_214:
mov rax, const_tbl+1
end_Gen_Const_214:

push rax
Gen_Lambda_Simple_215:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_220 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_216:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_216
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_217:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_217
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_220:
  MAKE_CLOSURE(rax, rbx, Lcode_218)
  jmp Lcont_219
  Lcode_218:
    push rbp
    mov rbp, rsp
    Gen_If_221:
Gen_Applic_231:

push SOB_NIL_ADDRESS
Gen_Var_Param_232:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_232:

push rax

push 1
Gen_Var_Bound_233:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_233:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_234:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_231:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_222
Gen_Var_Param_230:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_230:

jmp Lexit_223
Lelse_222:
Gen_ApplicTP_224:

push SOB_NIL_ADDRESS
Gen_Var_Param_225:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_225:

push rax
Gen_Var_Param_226:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_226:

push rax
Gen_Var_Bound_227:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_227:

push rax

push 3
Gen_Var_Bound_228:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_228:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_229:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 8                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_224:

Lexit_223:
end_Gen_If_221:

    leave
    ret
  Lcont_219:
  
end_Gen_Lambda_Simple_215:

push rax

push 3
Gen_Var_Bound_235:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_235:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_236:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 8                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_212:

    leave
    ret
  Lcont_209:
  
end_Gen_Lambda_Opt_203:

    leave
    ret
  Lcont_201:
  
end_Gen_Lambda_Simple_197:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_237:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_193:

mov qword [fvar_tbl+(32*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_192:

	call write_sob_if_not_void

Gen_Def_Var_Free_238:
Gen_Lambda_Opt_239:
; allocate ExtEnv to be of size |Env| + 1

  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9            ; for dummy frame

  cmp r9, 8                           ; if first lambda -> skip the old env copy
  mov qword[rbx], SOB_NIL_ADDRESS
  je first_lambda_246 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_242:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_242
  mov r8, 0
  mov rcx, PARAM_COUNT            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_243:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, PARAM_COUNT
  jle move_params_loop_243
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_246:
  MAKE_CLOSURE(rax, rbx, Lcode_244)
  jmp Lcont_245
  Lcode_244:
        push rbp
    mov rbp, rsp
    ;adjust the stack for the optional arguments
    mov rax, 1           ; num of params
    mov r15, qword[rbp + (8*3)]           ; num of args
    cmp rax, r15
    jg Opt_lable_247
    mov qword[rbp + (8*3)], rax           ; change num of args 
    ; make pairs
    mov r9, qword[rbp + 8*(3+r15)]        ; r9 holds last arg
    mov r10, SOB_NIL_ADDRESS              ; for the last pair
    mov r11, r15
    MAKE_PAIR(r8, r9, r10)                ; Pair(last_arg, NIL)
    loop_240: 
    cmp r11, rax                          ; if top = bottom, finish
    je finish_pairing_241 
    dec r11
    mov r10, qword[rbp + 8*(3 + r11)]
    mov r13, r8
    MAKE_PAIR(r8, r10, r13)
    jmp loop_240 
    finish_pairing_241:
    mov qword[rbp + 8*(3+rax)], r8          ; the last element is now a pair
  
    ; change the stack
    mov r9, rax
    mov r10, rax
    add r10, 4
    mov rdx, r15
    add rdx, 2
    _loop_240:
    cmp r10, 0
    je __loop_240
    dec r10
    dec rdx
    mov rcx, [rbp + r10*8]
    mov [rbp + 8*(2+rdx)], rcx
    jmp _loop_240       ; finised moving args
    
    __loop_240: 
    add rdx, 2
    shl rdx, 3
    add rsp, rdx
    mov rbp, rsp
    Opt_lable_247:
    Gen_Var_Param_248:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_248:

    leave
    ret
  Lcont_245:
  
end_Gen_Lambda_Opt_239:

mov qword [fvar_tbl+(33*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_238:

	call write_sob_if_not_void

Gen_Def_Var_Free_249:
Gen_Applic_250:

push SOB_NIL_ADDRESS
Gen_Var_Free_251:
mov rax, qword [fvar_tbl+(25*8)]
end_Gen_Var_Free_251:

push rax
Gen_Var_Free_252:
mov rax, qword [fvar_tbl+(3*8)]
end_Gen_Var_Free_252:

push rax
Gen_Var_Free_253:
mov rax, qword [fvar_tbl+(4*8)]
end_Gen_Var_Free_253:

push rax

push 3
Gen_Lambda_Simple_254:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_259 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_255:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_255
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_256:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_256
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_259:
  MAKE_CLOSURE(rax, rbx, Lcode_257)
  jmp Lcont_258
  Lcode_257:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_260:

push SOB_NIL_ADDRESS
Gen_Const_261:
mov rax, const_tbl+82
end_Gen_Const_261:

push rax

push 1
Gen_Lambda_Simple_262:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_267 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_263:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_263
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_264:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_264
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_267:
  MAKE_CLOSURE(rax, rbx, Lcode_265)
  jmp Lcont_266
  Lcode_265:
    push rbp
    mov rbp, rsp
    Gen_Seq_268:
Gen_Set_Var_Param_269:
Gen_Lambda_Simple_270:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_275 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_271:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_271
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_272:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_272
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_275:
  MAKE_CLOSURE(rax, rbx, Lcode_273)
  jmp Lcont_274
  Lcode_273:
    push rbp
    mov rbp, rsp
    Gen_Or_276:
Gen_Applic_278:

push SOB_NIL_ADDRESS
Gen_Var_Param_279:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_279:

push rax

push 1
Gen_Var_Bound_280:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_280:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_281:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_278:
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_277
Gen_If_282:
Gen_Applic_293:

push SOB_NIL_ADDRESS
Gen_Var_Param_294:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_294:

push rax

push 1
Gen_Var_Bound_295:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_295:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_296:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_293:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_283
Gen_ApplicTP_286:

push SOB_NIL_ADDRESS
Gen_Applic_287:

push SOB_NIL_ADDRESS
Gen_Var_Param_288:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_288:

push rax

push 1
Gen_Var_Bound_289:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_289:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_290:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_287:

push rax

push 1
Gen_Var_Free_291:
mov rax, qword [fvar_tbl+(34*8)]
end_Gen_Var_Free_291:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_292:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 6                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_286:

jmp Lexit_284
Lelse_283:
Gen_Const_285:
mov rax, const_tbl+2
end_Gen_Const_285:

Lexit_284:
end_Gen_If_282:

Lexit_277:
end_Gen_Or_276:

    leave
    ret
  Lcont_274:
  
end_Gen_Lambda_Simple_270:

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Set_Var_Param_269:

Gen_Var_Param_297:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_297:

end_Gen_Seq_268:

    leave
    ret
  Lcont_266:
  
end_Gen_Lambda_Simple_262:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_298:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 6                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_260:

    leave
    ret
  Lcont_258:
  
end_Gen_Lambda_Simple_254:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_299:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_250:

mov qword [fvar_tbl+(34*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_249:

	call write_sob_if_not_void

Gen_Def_Var_Free_300:
Gen_Applic_301:

push SOB_NIL_ADDRESS
Gen_Var_Free_302:
mov rax, qword [fvar_tbl+(17*8)]
end_Gen_Var_Free_302:

push rax
Gen_Var_Free_303:
mov rax, qword [fvar_tbl+(30*8)]
end_Gen_Var_Free_303:

push rax

push 2
Gen_Lambda_Simple_304:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_309 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_305:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_305
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_306:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_306
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_309:
  MAKE_CLOSURE(rax, rbx, Lcode_307)
  jmp Lcont_308
  Lcode_307:
    push rbp
    mov rbp, rsp
    Gen_Lambda_Simple_310:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_315 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_311:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_311
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_312:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_312
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_315:
  MAKE_CLOSURE(rax, rbx, Lcode_313)
  jmp Lcont_314
  Lcode_313:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_316:

push SOB_NIL_ADDRESS
Gen_Var_Param_317:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_317:

push rax
Gen_Const_318:
mov rax, const_tbl+91
end_Gen_Const_318:

push rax
Gen_Lambda_Simple_319:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_324 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_320:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_320
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_321:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_321
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_324:
  MAKE_CLOSURE(rax, rbx, Lcode_322)
  jmp Lcont_323
  Lcode_322:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_325:

push SOB_NIL_ADDRESS
Gen_Const_326:
mov rax, const_tbl+34
end_Gen_Const_326:

push rax
Gen_Var_Param_327:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_327:

push rax

push 2
Gen_Var_Bound_328:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_328:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_329:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_325:

    leave
    ret
  Lcont_323:
  
end_Gen_Lambda_Simple_319:

push rax

push 3
Gen_Var_Bound_330:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_330:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_331:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 8                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_316:

    leave
    ret
  Lcont_314:
  
end_Gen_Lambda_Simple_310:

    leave
    ret
  Lcont_308:
  
end_Gen_Lambda_Simple_304:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_332:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_301:

mov qword [fvar_tbl+(35*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_300:

	call write_sob_if_not_void

Gen_Def_Var_Free_333:
Gen_Applic_334:

push SOB_NIL_ADDRESS
Gen_Var_Free_335:
mov rax, qword [fvar_tbl+(12*8)]
end_Gen_Var_Free_335:

push rax
Gen_Var_Free_336:
mov rax, qword [fvar_tbl+(24*8)]
end_Gen_Var_Free_336:

push rax
Gen_Var_Free_337:
mov rax, qword [fvar_tbl+(4*8)]
end_Gen_Var_Free_337:

push rax

push 3
Gen_Lambda_Simple_338:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_343 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_339:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_339
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_340:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_340
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_343:
  MAKE_CLOSURE(rax, rbx, Lcode_341)
  jmp Lcont_342
  Lcode_341:
    push rbp
    mov rbp, rsp
    Gen_Lambda_Opt_344:
; allocate ExtEnv to be of size |Env| + 1

  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9            ; for dummy frame

  cmp r9, 8                           ; if first lambda -> skip the old env copy
  mov qword[rbx], SOB_NIL_ADDRESS
  je first_lambda_351 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_347:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_347
  mov r8, 0
  mov rcx, PARAM_COUNT            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_348:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, PARAM_COUNT
  jle move_params_loop_348
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_351:
  MAKE_CLOSURE(rax, rbx, Lcode_349)
  jmp Lcont_350
  Lcode_349:
        push rbp
    mov rbp, rsp
    ;adjust the stack for the optional arguments
    mov rax, 2           ; num of params
    mov r15, qword[rbp + (8*3)]           ; num of args
    cmp rax, r15
    jg Opt_lable_352
    mov qword[rbp + (8*3)], rax           ; change num of args 
    ; make pairs
    mov r9, qword[rbp + 8*(3+r15)]        ; r9 holds last arg
    mov r10, SOB_NIL_ADDRESS              ; for the last pair
    mov r11, r15
    MAKE_PAIR(r8, r9, r10)                ; Pair(last_arg, NIL)
    loop_345: 
    cmp r11, rax                          ; if top = bottom, finish
    je finish_pairing_346 
    dec r11
    mov r10, qword[rbp + 8*(3 + r11)]
    mov r13, r8
    MAKE_PAIR(r8, r10, r13)
    jmp loop_345 
    finish_pairing_346:
    mov qword[rbp + 8*(3+rax)], r8          ; the last element is now a pair
  
    ; change the stack
    mov r9, rax
    mov r10, rax
    add r10, 4
    mov rdx, r15
    add rdx, 2
    _loop_345:
    cmp r10, 0
    je __loop_345
    dec r10
    dec rdx
    mov rcx, [rbp + r10*8]
    mov [rbp + 8*(2+rdx)], rcx
    jmp _loop_345       ; finised moving args
    
    __loop_345: 
    add rdx, 2
    shl rdx, 3
    add rsp, rdx
    mov rbp, rsp
    Opt_lable_352:
    Gen_If_353:
Gen_Applic_369:

push SOB_NIL_ADDRESS
Gen_Var_Param_370:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_370:

push rax

push 1
Gen_Var_Bound_371:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_371:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_372:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_369:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_354
Gen_ApplicTP_364:

push SOB_NIL_ADDRESS
Gen_Const_365:
mov rax, const_tbl+100
end_Gen_Const_365:

push rax
Gen_Var_Param_366:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_366:

push rax

push 2
Gen_Var_Bound_367:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_367:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_368:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_364:

jmp Lexit_355
Lelse_354:
Gen_ApplicTP_356:

push SOB_NIL_ADDRESS
Gen_Applic_357:

push SOB_NIL_ADDRESS
Gen_Var_Param_358:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_358:

push rax

push 1
Gen_Var_Bound_359:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_359:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_360:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_357:

push rax
Gen_Var_Param_361:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_361:

push rax

push 2
Gen_Var_Bound_362:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_362:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_363:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_356:

Lexit_355:
end_Gen_If_353:

    leave
    ret
  Lcont_350:
  
end_Gen_Lambda_Opt_344:

    leave
    ret
  Lcont_342:
  
end_Gen_Lambda_Simple_338:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_373:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_334:

mov qword [fvar_tbl+(12*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_333:

	call write_sob_if_not_void

Gen_Def_Var_Free_374:
Gen_Lambda_Simple_375:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_380 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_376:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_376
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_377:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_377
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_380:
  MAKE_CLOSURE(rax, rbx, Lcode_378)
  jmp Lcont_379
  Lcode_378:
    push rbp
    mov rbp, rsp
    Gen_If_381:
Gen_Var_Param_386:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_386:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_382
Gen_Const_385:
mov rax, const_tbl+2
end_Gen_Const_385:

jmp Lexit_383
Lelse_382:
Gen_Const_384:
mov rax, const_tbl+4
end_Gen_Const_384:

Lexit_383:
end_Gen_If_381:

    leave
    ret
  Lcont_379:
  
end_Gen_Lambda_Simple_375:

mov qword [fvar_tbl+(36*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_374:

	call write_sob_if_not_void

Gen_Def_Var_Free_387:
Gen_Applic_388:

push SOB_NIL_ADDRESS
Gen_Var_Free_389:
mov rax, qword [fvar_tbl+(2*8)]
end_Gen_Var_Free_389:

push rax
Gen_Var_Free_390:
mov rax, qword [fvar_tbl+(1*8)]
end_Gen_Var_Free_390:

push rax

push 2
Gen_Lambda_Simple_391:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_396 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_392:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_392
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_393:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_393
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_396:
  MAKE_CLOSURE(rax, rbx, Lcode_394)
  jmp Lcont_395
  Lcode_394:
    push rbp
    mov rbp, rsp
    Gen_Lambda_Simple_397:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_402 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_398:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_398
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_399:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_399
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_402:
  MAKE_CLOSURE(rax, rbx, Lcode_400)
  jmp Lcont_401
  Lcode_400:
    push rbp
    mov rbp, rsp
    Gen_Or_403:
Gen_Applic_405:

push SOB_NIL_ADDRESS
Gen_Var_Param_406:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_406:

push rax

push 1
Gen_Var_Bound_407:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_407:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_408:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_405:
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_404
Gen_ApplicTP_409:

push SOB_NIL_ADDRESS
Gen_Var_Param_410:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_410:

push rax

push 1
Gen_Var_Bound_411:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_411:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_412:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 6                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_409:

Lexit_404:
end_Gen_Or_403:

    leave
    ret
  Lcont_401:
  
end_Gen_Lambda_Simple_397:

    leave
    ret
  Lcont_395:
  
end_Gen_Lambda_Simple_391:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_413:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_388:

mov qword [fvar_tbl+(37*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_387:

	call write_sob_if_not_void

Gen_Def_Var_Free_414:
Gen_Applic_415:

push SOB_NIL_ADDRESS
Gen_Var_Free_416:
mov rax, qword [fvar_tbl+(17*8)]
end_Gen_Var_Free_416:

push rax
Gen_Var_Free_417:
mov rax, qword [fvar_tbl+(30*8)]
end_Gen_Var_Free_417:

push rax

push 2
Gen_Lambda_Simple_418:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_423 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_419:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_419
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_420:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_420
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_423:
  MAKE_CLOSURE(rax, rbx, Lcode_421)
  jmp Lcont_422
  Lcode_421:
    push rbp
    mov rbp, rsp
    Gen_Lambda_Opt_424:
; allocate ExtEnv to be of size |Env| + 1

  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9            ; for dummy frame

  cmp r9, 8                           ; if first lambda -> skip the old env copy
  mov qword[rbx], SOB_NIL_ADDRESS
  je first_lambda_431 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_427:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_427
  mov r8, 0
  mov rcx, PARAM_COUNT            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_428:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, PARAM_COUNT
  jle move_params_loop_428
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_431:
  MAKE_CLOSURE(rax, rbx, Lcode_429)
  jmp Lcont_430
  Lcode_429:
        push rbp
    mov rbp, rsp
    ;adjust the stack for the optional arguments
    mov rax, 1           ; num of params
    mov r15, qword[rbp + (8*3)]           ; num of args
    cmp rax, r15
    jg Opt_lable_432
    mov qword[rbp + (8*3)], rax           ; change num of args 
    ; make pairs
    mov r9, qword[rbp + 8*(3+r15)]        ; r9 holds last arg
    mov r10, SOB_NIL_ADDRESS              ; for the last pair
    mov r11, r15
    MAKE_PAIR(r8, r9, r10)                ; Pair(last_arg, NIL)
    loop_425: 
    cmp r11, rax                          ; if top = bottom, finish
    je finish_pairing_426 
    dec r11
    mov r10, qword[rbp + 8*(3 + r11)]
    mov r13, r8
    MAKE_PAIR(r8, r10, r13)
    jmp loop_425 
    finish_pairing_426:
    mov qword[rbp + 8*(3+rax)], r8          ; the last element is now a pair
  
    ; change the stack
    mov r9, rax
    mov r10, rax
    add r10, 4
    mov rdx, r15
    add rdx, 2
    _loop_425:
    cmp r10, 0
    je __loop_425
    dec r10
    dec rdx
    mov rcx, [rbp + r10*8]
    mov [rbp + 8*(2+rdx)], rcx
    jmp _loop_425       ; finised moving args
    
    __loop_425: 
    add rdx, 2
    shl rdx, 3
    add rsp, rdx
    mov rbp, rsp
    Opt_lable_432:
    Gen_ApplicTP_433:

push SOB_NIL_ADDRESS
Gen_Var_Param_434:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_434:

push rax
Gen_Const_435:
mov rax, const_tbl+91
end_Gen_Const_435:

push rax
Gen_Var_Bound_436:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_436:

push rax

push 3
Gen_Var_Bound_437:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_437:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_438:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 8                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_433:

    leave
    ret
  Lcont_430:
  
end_Gen_Lambda_Opt_424:

    leave
    ret
  Lcont_422:
  
end_Gen_Lambda_Simple_418:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_439:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_415:

mov qword [fvar_tbl+(17*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_414:

	call write_sob_if_not_void

Gen_Def_Var_Free_440:
Gen_Applic_441:

push SOB_NIL_ADDRESS
Gen_Var_Free_442:
mov rax, qword [fvar_tbl+(18*8)]
end_Gen_Var_Free_442:

push rax
Gen_Var_Free_443:
mov rax, qword [fvar_tbl+(30*8)]
end_Gen_Var_Free_443:

push rax

push 2
Gen_Lambda_Simple_444:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_449 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_445:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_445
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_446:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_446
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_449:
  MAKE_CLOSURE(rax, rbx, Lcode_447)
  jmp Lcont_448
  Lcode_447:
    push rbp
    mov rbp, rsp
    Gen_Lambda_Opt_450:
; allocate ExtEnv to be of size |Env| + 1

  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9            ; for dummy frame

  cmp r9, 8                           ; if first lambda -> skip the old env copy
  mov qword[rbx], SOB_NIL_ADDRESS
  je first_lambda_457 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_453:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_453
  mov r8, 0
  mov rcx, PARAM_COUNT            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_454:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, PARAM_COUNT
  jle move_params_loop_454
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_457:
  MAKE_CLOSURE(rax, rbx, Lcode_455)
  jmp Lcont_456
  Lcode_455:
        push rbp
    mov rbp, rsp
    ;adjust the stack for the optional arguments
    mov rax, 1           ; num of params
    mov r15, qword[rbp + (8*3)]           ; num of args
    cmp rax, r15
    jg Opt_lable_458
    mov qword[rbp + (8*3)], rax           ; change num of args 
    ; make pairs
    mov r9, qword[rbp + 8*(3+r15)]        ; r9 holds last arg
    mov r10, SOB_NIL_ADDRESS              ; for the last pair
    mov r11, r15
    MAKE_PAIR(r8, r9, r10)                ; Pair(last_arg, NIL)
    loop_451: 
    cmp r11, rax                          ; if top = bottom, finish
    je finish_pairing_452 
    dec r11
    mov r10, qword[rbp + 8*(3 + r11)]
    mov r13, r8
    MAKE_PAIR(r8, r10, r13)
    jmp loop_451 
    finish_pairing_452:
    mov qword[rbp + 8*(3+rax)], r8          ; the last element is now a pair
  
    ; change the stack
    mov r9, rax
    mov r10, rax
    add r10, 4
    mov rdx, r15
    add rdx, 2
    _loop_451:
    cmp r10, 0
    je __loop_451
    dec r10
    dec rdx
    mov rcx, [rbp + r10*8]
    mov [rbp + 8*(2+rdx)], rcx
    jmp _loop_451       ; finised moving args
    
    __loop_451: 
    add rdx, 2
    shl rdx, 3
    add rsp, rdx
    mov rbp, rsp
    Opt_lable_458:
    Gen_ApplicTP_459:

push SOB_NIL_ADDRESS
Gen_Var_Param_460:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_460:

push rax
Gen_Const_461:
mov rax, const_tbl+34
end_Gen_Const_461:

push rax
Gen_Var_Bound_462:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_462:

push rax

push 3
Gen_Var_Bound_463:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_463:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_464:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 8                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_459:

    leave
    ret
  Lcont_456:
  
end_Gen_Lambda_Opt_450:

    leave
    ret
  Lcont_448:
  
end_Gen_Lambda_Simple_444:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_465:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_441:

mov qword [fvar_tbl+(18*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_440:

	call write_sob_if_not_void

Gen_Def_Var_Free_466:
Gen_Applic_467:

push SOB_NIL_ADDRESS
Gen_Var_Free_468:
mov rax, qword [fvar_tbl+(4*8)]
end_Gen_Var_Free_468:

push rax
Gen_Var_Free_469:
mov rax, qword [fvar_tbl+(17*8)]
end_Gen_Var_Free_469:

push rax
Gen_Var_Free_470:
mov rax, qword [fvar_tbl+(19*8)]
end_Gen_Var_Free_470:

push rax
Gen_Var_Free_471:
mov rax, qword [fvar_tbl+(28*8)]
end_Gen_Var_Free_471:

push rax

push 4
Gen_Lambda_Simple_472:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_477 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_473:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_473
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_474:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_474
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_477:
  MAKE_CLOSURE(rax, rbx, Lcode_475)
  jmp Lcont_476
  Lcode_475:
    push rbp
    mov rbp, rsp
    Gen_Lambda_Opt_478:
; allocate ExtEnv to be of size |Env| + 1

  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9            ; for dummy frame

  cmp r9, 8                           ; if first lambda -> skip the old env copy
  mov qword[rbx], SOB_NIL_ADDRESS
  je first_lambda_485 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_481:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_481
  mov r8, 0
  mov rcx, PARAM_COUNT            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_482:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, PARAM_COUNT
  jle move_params_loop_482
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_485:
  MAKE_CLOSURE(rax, rbx, Lcode_483)
  jmp Lcont_484
  Lcode_483:
        push rbp
    mov rbp, rsp
    ;adjust the stack for the optional arguments
    mov rax, 2           ; num of params
    mov r15, qword[rbp + (8*3)]           ; num of args
    cmp rax, r15
    jg Opt_lable_486
    mov qword[rbp + (8*3)], rax           ; change num of args 
    ; make pairs
    mov r9, qword[rbp + 8*(3+r15)]        ; r9 holds last arg
    mov r10, SOB_NIL_ADDRESS              ; for the last pair
    mov r11, r15
    MAKE_PAIR(r8, r9, r10)                ; Pair(last_arg, NIL)
    loop_479: 
    cmp r11, rax                          ; if top = bottom, finish
    je finish_pairing_480 
    dec r11
    mov r10, qword[rbp + 8*(3 + r11)]
    mov r13, r8
    MAKE_PAIR(r8, r10, r13)
    jmp loop_479 
    finish_pairing_480:
    mov qword[rbp + 8*(3+rax)], r8          ; the last element is now a pair
  
    ; change the stack
    mov r9, rax
    mov r10, rax
    add r10, 4
    mov rdx, r15
    add rdx, 2
    _loop_479:
    cmp r10, 0
    je __loop_479
    dec r10
    dec rdx
    mov rcx, [rbp + r10*8]
    mov [rbp + 8*(2+rdx)], rcx
    jmp _loop_479       ; finised moving args
    
    __loop_479: 
    add rdx, 2
    shl rdx, 3
    add rsp, rdx
    mov rbp, rsp
    Opt_lable_486:
    Gen_If_487:
Gen_Applic_504:

push SOB_NIL_ADDRESS
Gen_Var_Param_505:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_505:

push rax

push 1
Gen_Var_Bound_506:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 3)]
end_Gen_Var_Bound_506:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_507:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_504:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_488
Gen_ApplicTP_499:

push SOB_NIL_ADDRESS
Gen_Var_Param_500:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_500:

push rax
Gen_Const_501:
mov rax, const_tbl+91
end_Gen_Const_501:

push rax

push 2
Gen_Var_Bound_502:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_502:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_503:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_499:

jmp Lexit_489
Lelse_488:
Gen_ApplicTP_490:

push SOB_NIL_ADDRESS
Gen_Applic_491:

push SOB_NIL_ADDRESS
Gen_Var_Param_492:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_492:

push rax
Gen_Var_Bound_493:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_493:

push rax

push 2
Gen_Var_Bound_494:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_494:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_495:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_491:

push rax
Gen_Var_Param_496:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_496:

push rax

push 2
Gen_Var_Bound_497:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_497:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_498:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_490:

Lexit_489:
end_Gen_If_487:

    leave
    ret
  Lcont_484:
  
end_Gen_Lambda_Opt_478:

    leave
    ret
  Lcont_476:
  
end_Gen_Lambda_Simple_472:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_508:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_467:

mov qword [fvar_tbl+(19*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_466:

	call write_sob_if_not_void

Gen_Def_Var_Free_509:
Gen_Applic_510:

push SOB_NIL_ADDRESS
Gen_Var_Free_511:
mov rax, qword [fvar_tbl+(4*8)]
end_Gen_Var_Free_511:

push rax
Gen_Var_Free_512:
mov rax, qword [fvar_tbl+(18*8)]
end_Gen_Var_Free_512:

push rax
Gen_Var_Free_513:
mov rax, qword [fvar_tbl+(20*8)]
end_Gen_Var_Free_513:

push rax
Gen_Var_Free_514:
mov rax, qword [fvar_tbl+(28*8)]
end_Gen_Var_Free_514:

push rax

push 4
Gen_Lambda_Simple_515:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_520 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_516:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_516
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_517:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_517
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_520:
  MAKE_CLOSURE(rax, rbx, Lcode_518)
  jmp Lcont_519
  Lcode_518:
    push rbp
    mov rbp, rsp
    Gen_Lambda_Opt_521:
; allocate ExtEnv to be of size |Env| + 1

  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9            ; for dummy frame

  cmp r9, 8                           ; if first lambda -> skip the old env copy
  mov qword[rbx], SOB_NIL_ADDRESS
  je first_lambda_528 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_524:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_524
  mov r8, 0
  mov rcx, PARAM_COUNT            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_525:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, PARAM_COUNT
  jle move_params_loop_525
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_528:
  MAKE_CLOSURE(rax, rbx, Lcode_526)
  jmp Lcont_527
  Lcode_526:
        push rbp
    mov rbp, rsp
    ;adjust the stack for the optional arguments
    mov rax, 2           ; num of params
    mov r15, qword[rbp + (8*3)]           ; num of args
    cmp rax, r15
    jg Opt_lable_529
    mov qword[rbp + (8*3)], rax           ; change num of args 
    ; make pairs
    mov r9, qword[rbp + 8*(3+r15)]        ; r9 holds last arg
    mov r10, SOB_NIL_ADDRESS              ; for the last pair
    mov r11, r15
    MAKE_PAIR(r8, r9, r10)                ; Pair(last_arg, NIL)
    loop_522: 
    cmp r11, rax                          ; if top = bottom, finish
    je finish_pairing_523 
    dec r11
    mov r10, qword[rbp + 8*(3 + r11)]
    mov r13, r8
    MAKE_PAIR(r8, r10, r13)
    jmp loop_522 
    finish_pairing_523:
    mov qword[rbp + 8*(3+rax)], r8          ; the last element is now a pair
  
    ; change the stack
    mov r9, rax
    mov r10, rax
    add r10, 4
    mov rdx, r15
    add rdx, 2
    _loop_522:
    cmp r10, 0
    je __loop_522
    dec r10
    dec rdx
    mov rcx, [rbp + r10*8]
    mov [rbp + 8*(2+rdx)], rcx
    jmp _loop_522       ; finised moving args
    
    __loop_522: 
    add rdx, 2
    shl rdx, 3
    add rsp, rdx
    mov rbp, rsp
    Opt_lable_529:
    Gen_If_530:
Gen_Applic_547:

push SOB_NIL_ADDRESS
Gen_Var_Param_548:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_548:

push rax

push 1
Gen_Var_Bound_549:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 3)]
end_Gen_Var_Bound_549:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_550:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_547:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_531
Gen_ApplicTP_542:

push SOB_NIL_ADDRESS
Gen_Var_Param_543:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_543:

push rax
Gen_Const_544:
mov rax, const_tbl+34
end_Gen_Const_544:

push rax

push 2
Gen_Var_Bound_545:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_545:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_546:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_542:

jmp Lexit_532
Lelse_531:
Gen_ApplicTP_533:

push SOB_NIL_ADDRESS
Gen_Applic_534:

push SOB_NIL_ADDRESS
Gen_Var_Param_535:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_535:

push rax
Gen_Var_Bound_536:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_536:

push rax

push 2
Gen_Var_Bound_537:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_537:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_538:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_534:

push rax
Gen_Var_Param_539:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_539:

push rax

push 2
Gen_Var_Bound_540:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_540:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_541:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_533:

Lexit_532:
end_Gen_If_530:

    leave
    ret
  Lcont_527:
  
end_Gen_Lambda_Opt_521:

    leave
    ret
  Lcont_519:
  
end_Gen_Lambda_Simple_515:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_551:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_510:

mov qword [fvar_tbl+(20*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_509:

	call write_sob_if_not_void

Gen_Def_Var_Free_552:
Gen_Applic_553:

push SOB_NIL_ADDRESS
Gen_Var_Free_554:
mov rax, qword [fvar_tbl+(25*8)]
end_Gen_Var_Free_554:

push rax
Gen_Var_Free_555:
mov rax, qword [fvar_tbl+(24*8)]
end_Gen_Var_Free_555:

push rax
Gen_Var_Free_556:
mov rax, qword [fvar_tbl+(21*8)]
end_Gen_Var_Free_556:

push rax
Gen_Var_Free_557:
mov rax, qword [fvar_tbl+(4*8)]
end_Gen_Var_Free_557:

push rax

push 4
Gen_Lambda_Simple_558:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_563 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_559:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_559
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_560:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_560
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_563:
  MAKE_CLOSURE(rax, rbx, Lcode_561)
  jmp Lcont_562
  Lcode_561:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_564:

push SOB_NIL_ADDRESS
Gen_Const_565:
mov rax, const_tbl+82
end_Gen_Const_565:

push rax

push 1
Gen_Lambda_Simple_566:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_571 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_567:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_567
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_568:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_568
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_571:
  MAKE_CLOSURE(rax, rbx, Lcode_569)
  jmp Lcont_570
  Lcode_569:
    push rbp
    mov rbp, rsp
    Gen_Seq_572:
Gen_Set_Var_Param_573:
Gen_Box_574:
Gen_Var_Param_575:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_575:

MALLOC r10, 8
mov qword[r10], rax
mov rax, r10
end_Gen_Box_574:

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Set_Var_Param_573:

Gen_Seq_576:
Gen_Box_get_577:
Gen_Lambda_Simple_579:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_584 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_580:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_580
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_581:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_581
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_584:
  MAKE_CLOSURE(rax, rbx, Lcode_582)
  jmp Lcont_583
  Lcode_582:
    push rbp
    mov rbp, rsp
    Gen_If_585:
Gen_Applic_613:

push SOB_NIL_ADDRESS
Gen_Var_Param_614:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_614:

push rax

push 1
Gen_Var_Bound_615:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_615:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_616:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_613:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_586
Gen_Const_612:
mov rax, const_tbl+4
end_Gen_Const_612:

jmp Lexit_587
Lelse_586:
Gen_If_588:
Gen_Applic_604:

push SOB_NIL_ADDRESS
Gen_Applic_605:

push SOB_NIL_ADDRESS
Gen_Var_Param_606:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_606:

push rax

push 1
Gen_Var_Bound_607:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_607:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_608:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_605:

push rax
Gen_Var_Param_609:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_609:

push rax

push 2
Gen_Var_Bound_610:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_610:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_611:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_604:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_589
Gen_ApplicTP_592:

push SOB_NIL_ADDRESS
Gen_Applic_593:

push SOB_NIL_ADDRESS
Gen_Var_Param_594:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_594:

push rax

push 1
Gen_Var_Bound_595:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 3)]
end_Gen_Var_Bound_595:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_596:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_593:

push rax
Gen_Applic_597:

push SOB_NIL_ADDRESS
Gen_Var_Param_598:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_598:

push rax

push 1
Gen_Var_Bound_599:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_599:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_600:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_597:

push rax

push 2
Gen_Box_Get_601:
Gen_Var_Bound_602:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_602:

mov rax, qword [rax]
end_Gen_Box_Get_601:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_603:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_592:

jmp Lexit_590
Lelse_589:
Gen_Const_591:
mov rax, const_tbl+2
end_Gen_Const_591:

Lexit_590:
end_Gen_If_588:

Lexit_587:
end_Gen_If_585:

    leave
    ret
  Lcont_583:
  
end_Gen_Lambda_Simple_579:

push rax
Gen_Var_Param_578:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_578:

pop qword [rax]
mov rax, SOB_VOID_ADDRESS
end_Gen_Box_get_577:

Gen_Lambda_Opt_617:
; allocate ExtEnv to be of size |Env| + 1

  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9            ; for dummy frame

  cmp r9, 8                           ; if first lambda -> skip the old env copy
  mov qword[rbx], SOB_NIL_ADDRESS
  je first_lambda_624 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_620:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_620
  mov r8, 0
  mov rcx, PARAM_COUNT            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_621:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, PARAM_COUNT
  jle move_params_loop_621
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_624:
  MAKE_CLOSURE(rax, rbx, Lcode_622)
  jmp Lcont_623
  Lcode_622:
        push rbp
    mov rbp, rsp
    ;adjust the stack for the optional arguments
    mov rax, 2           ; num of params
    mov r15, qword[rbp + (8*3)]           ; num of args
    cmp rax, r15
    jg Opt_lable_625
    mov qword[rbp + (8*3)], rax           ; change num of args 
    ; make pairs
    mov r9, qword[rbp + 8*(3+r15)]        ; r9 holds last arg
    mov r10, SOB_NIL_ADDRESS              ; for the last pair
    mov r11, r15
    MAKE_PAIR(r8, r9, r10)                ; Pair(last_arg, NIL)
    loop_618: 
    cmp r11, rax                          ; if top = bottom, finish
    je finish_pairing_619 
    dec r11
    mov r10, qword[rbp + 8*(3 + r11)]
    mov r13, r8
    MAKE_PAIR(r8, r10, r13)
    jmp loop_618 
    finish_pairing_619:
    mov qword[rbp + 8*(3+rax)], r8          ; the last element is now a pair
  
    ; change the stack
    mov r9, rax
    mov r10, rax
    add r10, 4
    mov rdx, r15
    add rdx, 2
    _loop_618:
    cmp r10, 0
    je __loop_618
    dec r10
    dec rdx
    mov rcx, [rbp + r10*8]
    mov [rbp + 8*(2+rdx)], rcx
    jmp _loop_618       ; finised moving args
    
    __loop_618: 
    add rdx, 2
    shl rdx, 3
    add rsp, rdx
    mov rbp, rsp
    Opt_lable_625:
    Gen_ApplicTP_626:

push SOB_NIL_ADDRESS
Gen_Var_Param_627:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_627:

push rax
Gen_Var_Param_628:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_628:

push rax

push 2
Gen_Box_Get_629:
Gen_Var_Bound_630:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_630:

mov rax, qword [rax]
end_Gen_Box_Get_629:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_631:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_626:

    leave
    ret
  Lcont_623:
  
end_Gen_Lambda_Opt_617:

end_Gen_Seq_576:

end_Gen_Seq_572:

    leave
    ret
  Lcont_570:
  
end_Gen_Lambda_Simple_566:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_632:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 6                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_564:

    leave
    ret
  Lcont_562:
  
end_Gen_Lambda_Simple_558:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_633:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_553:

mov qword [fvar_tbl+(21*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_552:

	call write_sob_if_not_void

Gen_Def_Var_Free_634:
Gen_Applic_635:

push SOB_NIL_ADDRESS
Gen_Var_Free_636:
mov rax, qword [fvar_tbl+(25*8)]
end_Gen_Var_Free_636:

push rax
Gen_Var_Free_637:
mov rax, qword [fvar_tbl+(24*8)]
end_Gen_Var_Free_637:

push rax
Gen_Var_Free_638:
mov rax, qword [fvar_tbl+(36*8)]
end_Gen_Var_Free_638:

push rax
Gen_Var_Free_639:
mov rax, qword [fvar_tbl+(22*8)]
end_Gen_Var_Free_639:

push rax
Gen_Var_Free_640:
mov rax, qword [fvar_tbl+(21*8)]
end_Gen_Var_Free_640:

push rax
Gen_Var_Free_641:
mov rax, qword [fvar_tbl+(4*8)]
end_Gen_Var_Free_641:

push rax

push 6
Gen_Lambda_Simple_642:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_647 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_643:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_643
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_644:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_644
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_647:
  MAKE_CLOSURE(rax, rbx, Lcode_645)
  jmp Lcont_646
  Lcode_645:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_648:

push SOB_NIL_ADDRESS
Gen_Const_649:
mov rax, const_tbl+82
end_Gen_Const_649:

push rax

push 1
Gen_Lambda_Simple_650:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_655 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_651:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_651
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_652:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_652
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_655:
  MAKE_CLOSURE(rax, rbx, Lcode_653)
  jmp Lcont_654
  Lcode_653:
    push rbp
    mov rbp, rsp
    Gen_Seq_656:
Gen_Set_Var_Param_657:
Gen_Box_658:
Gen_Var_Param_659:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_659:

MALLOC r10, 8
mov qword[r10], rax
mov rax, r10
end_Gen_Box_658:

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Set_Var_Param_657:

Gen_Seq_660:
Gen_Box_get_661:
Gen_Lambda_Simple_663:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_668 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_664:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_664
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_665:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_665
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_668:
  MAKE_CLOSURE(rax, rbx, Lcode_666)
  jmp Lcont_667
  Lcode_666:
    push rbp
    mov rbp, rsp
    Gen_If_669:
Gen_Applic_710:

push SOB_NIL_ADDRESS
Gen_Var_Param_711:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_711:

push rax

push 1
Gen_Var_Bound_712:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_712:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_713:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_710:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_670
Gen_Const_709:
mov rax, const_tbl+4
end_Gen_Const_709:

jmp Lexit_671
Lelse_670:
Gen_If_672:
Gen_Applic_688:

push SOB_NIL_ADDRESS
Gen_Or_689:
Gen_Applic_691:

push SOB_NIL_ADDRESS
Gen_Applic_692:

push SOB_NIL_ADDRESS
Gen_Var_Param_693:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_693:

push rax

push 1
Gen_Var_Bound_694:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 4)]
end_Gen_Var_Bound_694:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_695:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_692:

push rax
Gen_Var_Param_696:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_696:

push rax

push 2
Gen_Var_Bound_697:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_697:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_698:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_691:
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_690
Gen_Applic_699:

push SOB_NIL_ADDRESS
Gen_Applic_700:

push SOB_NIL_ADDRESS
Gen_Var_Param_701:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_701:

push rax

push 1
Gen_Var_Bound_702:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 4)]
end_Gen_Var_Bound_702:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_703:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_700:

push rax
Gen_Var_Param_704:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_704:

push rax

push 2
Gen_Var_Bound_705:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_705:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_706:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_699:

Lexit_690:
end_Gen_Or_689:

push rax

push 1
Gen_Var_Bound_707:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 3)]
end_Gen_Var_Bound_707:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_708:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_688:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_673
Gen_ApplicTP_676:

push SOB_NIL_ADDRESS
Gen_Applic_677:

push SOB_NIL_ADDRESS
Gen_Var_Param_678:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_678:

push rax

push 1
Gen_Var_Bound_679:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 5)]
end_Gen_Var_Bound_679:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_680:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_677:

push rax
Gen_Applic_681:

push SOB_NIL_ADDRESS
Gen_Var_Param_682:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_682:

push rax

push 1
Gen_Var_Bound_683:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 4)]
end_Gen_Var_Bound_683:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_684:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_681:

push rax

push 2
Gen_Box_Get_685:
Gen_Var_Bound_686:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_686:

mov rax, qword [rax]
end_Gen_Box_Get_685:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_687:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_676:

jmp Lexit_674
Lelse_673:
Gen_Const_675:
mov rax, const_tbl+2
end_Gen_Const_675:

Lexit_674:
end_Gen_If_672:

Lexit_671:
end_Gen_If_669:

    leave
    ret
  Lcont_667:
  
end_Gen_Lambda_Simple_663:

push rax
Gen_Var_Param_662:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_662:

pop qword [rax]
mov rax, SOB_VOID_ADDRESS
end_Gen_Box_get_661:

Gen_Lambda_Opt_714:
; allocate ExtEnv to be of size |Env| + 1

  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9            ; for dummy frame

  cmp r9, 8                           ; if first lambda -> skip the old env copy
  mov qword[rbx], SOB_NIL_ADDRESS
  je first_lambda_721 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_717:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_717
  mov r8, 0
  mov rcx, PARAM_COUNT            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_718:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, PARAM_COUNT
  jle move_params_loop_718
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_721:
  MAKE_CLOSURE(rax, rbx, Lcode_719)
  jmp Lcont_720
  Lcode_719:
        push rbp
    mov rbp, rsp
    ;adjust the stack for the optional arguments
    mov rax, 2           ; num of params
    mov r15, qword[rbp + (8*3)]           ; num of args
    cmp rax, r15
    jg Opt_lable_722
    mov qword[rbp + (8*3)], rax           ; change num of args 
    ; make pairs
    mov r9, qword[rbp + 8*(3+r15)]        ; r9 holds last arg
    mov r10, SOB_NIL_ADDRESS              ; for the last pair
    mov r11, r15
    MAKE_PAIR(r8, r9, r10)                ; Pair(last_arg, NIL)
    loop_715: 
    cmp r11, rax                          ; if top = bottom, finish
    je finish_pairing_716 
    dec r11
    mov r10, qword[rbp + 8*(3 + r11)]
    mov r13, r8
    MAKE_PAIR(r8, r10, r13)
    jmp loop_715 
    finish_pairing_716:
    mov qword[rbp + 8*(3+rax)], r8          ; the last element is now a pair
  
    ; change the stack
    mov r9, rax
    mov r10, rax
    add r10, 4
    mov rdx, r15
    add rdx, 2
    _loop_715:
    cmp r10, 0
    je __loop_715
    dec r10
    dec rdx
    mov rcx, [rbp + r10*8]
    mov [rbp + 8*(2+rdx)], rcx
    jmp _loop_715       ; finised moving args
    
    __loop_715: 
    add rdx, 2
    shl rdx, 3
    add rsp, rdx
    mov rbp, rsp
    Opt_lable_722:
    Gen_ApplicTP_723:

push SOB_NIL_ADDRESS
Gen_Var_Param_724:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_724:

push rax
Gen_Var_Param_725:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_725:

push rax

push 2
Gen_Box_Get_726:
Gen_Var_Bound_727:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_727:

mov rax, qword [rax]
end_Gen_Box_Get_726:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_728:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_723:

    leave
    ret
  Lcont_720:
  
end_Gen_Lambda_Opt_714:

end_Gen_Seq_660:

end_Gen_Seq_656:

    leave
    ret
  Lcont_654:
  
end_Gen_Lambda_Simple_650:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_729:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 6                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_648:

    leave
    ret
  Lcont_646:
  
end_Gen_Lambda_Simple_642:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_730:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_635:

mov qword [fvar_tbl+(38*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_634:

	call write_sob_if_not_void

Gen_Def_Var_Free_731:
Gen_Applic_732:

push SOB_NIL_ADDRESS
Gen_Var_Free_733:
mov rax, qword [fvar_tbl+(22*8)]
end_Gen_Var_Free_733:

push rax

push 1
Gen_Lambda_Simple_734:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_739 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_735:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_735
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_736:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_736
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_739:
  MAKE_CLOSURE(rax, rbx, Lcode_737)
  jmp Lcont_738
  Lcode_737:
    push rbp
    mov rbp, rsp
    Gen_Lambda_Simple_740:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_745 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_741:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_741
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_742:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_742
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_745:
  MAKE_CLOSURE(rax, rbx, Lcode_743)
  jmp Lcont_744
  Lcode_743:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_746:

push SOB_NIL_ADDRESS
Gen_Const_747:
mov rax, const_tbl+91
end_Gen_Const_747:

push rax
Gen_Var_Param_748:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_748:

push rax

push 2
Gen_Var_Bound_749:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_749:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_750:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_746:

    leave
    ret
  Lcont_744:
  
end_Gen_Lambda_Simple_740:

    leave
    ret
  Lcont_738:
  
end_Gen_Lambda_Simple_734:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_751:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_732:

mov qword [fvar_tbl+(39*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_731:

	call write_sob_if_not_void

Gen_Def_Var_Free_752:
Gen_Applic_753:

push SOB_NIL_ADDRESS
Gen_Var_Free_754:
mov rax, qword [fvar_tbl+(19*8)]
end_Gen_Var_Free_754:

push rax
Gen_Var_Free_755:
mov rax, qword [fvar_tbl+(21*8)]
end_Gen_Var_Free_755:

push rax
Gen_Var_Free_756:
mov rax, qword [fvar_tbl+(9*8)]
end_Gen_Var_Free_756:

push rax
Gen_Var_Free_757:
mov rax, qword [fvar_tbl+(10*8)]
end_Gen_Var_Free_757:

push rax

push 4
Gen_Lambda_Simple_758:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_763 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_759:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_759
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_760:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_760
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_763:
  MAKE_CLOSURE(rax, rbx, Lcode_761)
  jmp Lcont_762
  Lcode_761:
    push rbp
    mov rbp, rsp
    Gen_Lambda_Simple_764:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_769 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_765:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_765
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_766:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_766
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_769:
  MAKE_CLOSURE(rax, rbx, Lcode_767)
  jmp Lcont_768
  Lcode_767:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_770:

push SOB_NIL_ADDRESS
Gen_Const_771:
mov rax, const_tbl+82
end_Gen_Const_771:

push rax

push 1
Gen_Lambda_Simple_772:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_777 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_773:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_773
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_774:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_774
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_777:
  MAKE_CLOSURE(rax, rbx, Lcode_775)
  jmp Lcont_776
  Lcode_775:
    push rbp
    mov rbp, rsp
    Gen_Seq_778:
Gen_Set_Var_Param_779:
Gen_Box_780:
Gen_Var_Param_781:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_781:

MALLOC r10, 8
mov qword[r10], rax
mov rax, r10
end_Gen_Box_780:

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Set_Var_Param_779:

Gen_Seq_782:
Gen_Box_get_783:
Gen_Lambda_Simple_785:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 32                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_790 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_786:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 3
  jle loop_786
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_787:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_787
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_790:
  MAKE_CLOSURE(rax, rbx, Lcode_788)
  jmp Lcont_789
  Lcode_788:
    push rbp
    mov rbp, rsp
    Gen_If_791:
Gen_Applic_813:

push SOB_NIL_ADDRESS
Gen_Const_814:
mov rax, const_tbl+91
end_Gen_Const_814:

push rax
Gen_Var_Param_815:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_815:

push rax

push 2
Gen_Var_Bound_816:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 2)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_816:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_817:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_813:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_792
Gen_Var_Param_812:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_812:

jmp Lexit_793
Lelse_792:
Gen_ApplicTP_794:

push SOB_NIL_ADDRESS
Gen_Applic_795:

push SOB_NIL_ADDRESS
Gen_Var_Param_796:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_796:

push rax
Gen_Applic_797:

push SOB_NIL_ADDRESS
Gen_Var_Param_798:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_798:

push rax
Gen_Var_Bound_799:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_799:

push rax

push 2
Gen_Var_Bound_800:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_800:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_801:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_797:

push rax

push 2
Gen_Var_Free_802:
mov rax, qword [fvar_tbl+(23*8)]
end_Gen_Var_Free_802:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_803:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_795:

push rax
Gen_Applic_804:

push SOB_NIL_ADDRESS
Gen_Const_805:
mov rax, const_tbl+34
end_Gen_Const_805:

push rax
Gen_Var_Param_806:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_806:

push rax

push 2
Gen_Var_Bound_807:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 2)]
mov rax, qword[rax + (8 * 3)]
end_Gen_Var_Bound_807:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_808:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_804:

push rax

push 2
Gen_Box_Get_809:
Gen_Var_Bound_810:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_810:

mov rax, qword [rax]
end_Gen_Box_Get_809:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_811:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_794:

Lexit_793:
end_Gen_If_791:

    leave
    ret
  Lcont_789:
  
end_Gen_Lambda_Simple_785:

push rax
Gen_Var_Param_784:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_784:

pop qword [rax]
mov rax, SOB_VOID_ADDRESS
end_Gen_Box_get_783:

Gen_ApplicTP_818:

push SOB_NIL_ADDRESS
Gen_Const_819:
mov rax, const_tbl+1
end_Gen_Const_819:

push rax
Gen_Applic_820:

push SOB_NIL_ADDRESS
Gen_Const_821:
mov rax, const_tbl+34
end_Gen_Const_821:

push rax
Gen_Applic_822:

push SOB_NIL_ADDRESS
Gen_Var_Bound_823:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_823:

push rax

push 1
Gen_Var_Bound_824:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_824:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_825:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_822:

push rax

push 2
Gen_Var_Bound_826:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 3)]
end_Gen_Var_Bound_826:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_827:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_820:

push rax

push 2
Gen_Box_Get_828:
Gen_Var_Param_829:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_829:

mov rax, qword [rax]
end_Gen_Box_Get_828:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_830:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_818:

end_Gen_Seq_782:

end_Gen_Seq_778:

    leave
    ret
  Lcont_776:
  
end_Gen_Lambda_Simple_772:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_831:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 6                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_770:

    leave
    ret
  Lcont_768:
  
end_Gen_Lambda_Simple_764:

    leave
    ret
  Lcont_762:
  
end_Gen_Lambda_Simple_758:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_832:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_753:

mov qword [fvar_tbl+(40*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_752:

	call write_sob_if_not_void

Gen_Def_Var_Free_833:
Gen_Applic_834:

push SOB_NIL_ADDRESS
Gen_Var_Free_835:
mov rax, qword [fvar_tbl+(14*8)]
end_Gen_Var_Free_835:

push rax
Gen_Var_Free_836:
mov rax, qword [fvar_tbl+(25*8)]
end_Gen_Var_Free_836:

push rax
Gen_Var_Free_837:
mov rax, qword [fvar_tbl+(24*8)]
end_Gen_Var_Free_837:

push rax
Gen_Var_Free_838:
mov rax, qword [fvar_tbl+(16*8)]
end_Gen_Var_Free_838:

push rax
Gen_Var_Free_839:
mov rax, qword [fvar_tbl+(6*8)]
end_Gen_Var_Free_839:

push rax
Gen_Var_Free_840:
mov rax, qword [fvar_tbl+(5*8)]
end_Gen_Var_Free_840:

push rax
Gen_Var_Free_841:
mov rax, qword [fvar_tbl+(3*8)]
end_Gen_Var_Free_841:

push rax
Gen_Var_Free_842:
mov rax, qword [fvar_tbl+(1*8)]
end_Gen_Var_Free_842:

push rax
Gen_Var_Free_843:
mov rax, qword [fvar_tbl+(2*8)]
end_Gen_Var_Free_843:

push rax
Gen_Var_Free_844:
mov rax, qword [fvar_tbl+(40*8)]
end_Gen_Var_Free_844:

push rax
Gen_Var_Free_845:
mov rax, qword [fvar_tbl+(22*8)]
end_Gen_Var_Free_845:

push rax

push 11
Gen_Lambda_Simple_846:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_851 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_847:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_847
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_848:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_848
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_851:
  MAKE_CLOSURE(rax, rbx, Lcode_849)
  jmp Lcont_850
  Lcode_849:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_852:

push SOB_NIL_ADDRESS
Gen_Const_853:
mov rax, const_tbl+82
end_Gen_Const_853:

push rax

push 1
Gen_Lambda_Simple_854:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_859 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_855:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_855
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_856:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_856
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_859:
  MAKE_CLOSURE(rax, rbx, Lcode_857)
  jmp Lcont_858
  Lcode_857:
    push rbp
    mov rbp, rsp
    Gen_Seq_860:
Gen_Set_Var_Param_861:
Gen_Box_862:
Gen_Var_Param_863:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_863:

MALLOC r10, 8
mov qword[r10], rax
mov rax, r10
end_Gen_Box_862:

mov qword [rbp + 8 * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Set_Var_Param_861:

Gen_Seq_864:
Gen_Box_get_865:
Gen_Lambda_Simple_867:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_872 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_868:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_868
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_869:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_869
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_872:
  MAKE_CLOSURE(rax, rbx, Lcode_870)
  jmp Lcont_871
  Lcode_870:
    push rbp
    mov rbp, rsp
    Gen_Or_873:
Gen_If_875:
Gen_Applic_892:

push SOB_NIL_ADDRESS
Gen_Var_Param_893:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_893:

push rax

push 1
Gen_Var_Bound_894:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_894:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_895:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_892:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_876
Gen_If_879:
Gen_Applic_888:

push SOB_NIL_ADDRESS
Gen_Var_Param_889:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_889:

push rax

push 1
Gen_Var_Bound_890:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 2)]
end_Gen_Var_Bound_890:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_891:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_888:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_880
Gen_Applic_883:

push SOB_NIL_ADDRESS
Gen_Var_Param_884:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_884:

push rax
Gen_Var_Param_885:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_885:

push rax

push 2
Gen_Var_Bound_886:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_886:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_887:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_883:

jmp Lexit_881
Lelse_880:
Gen_Const_882:
mov rax, const_tbl+2
end_Gen_Const_882:

Lexit_881:
end_Gen_If_879:

jmp Lexit_877
Lelse_876:
Gen_Const_878:
mov rax, const_tbl+2
end_Gen_Const_878:

Lexit_877:
end_Gen_If_875:
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_874
Gen_If_896:
Gen_Applic_913:

push SOB_NIL_ADDRESS
Gen_Var_Param_914:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_914:

push rax

push 1
Gen_Var_Bound_915:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 3)]
end_Gen_Var_Bound_915:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_916:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_913:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_897
Gen_If_900:
Gen_Applic_909:

push SOB_NIL_ADDRESS
Gen_Var_Param_910:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_910:

push rax

push 1
Gen_Var_Bound_911:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 3)]
end_Gen_Var_Bound_911:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_912:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_909:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_901
Gen_Applic_904:

push SOB_NIL_ADDRESS
Gen_Var_Param_905:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_905:

push rax
Gen_Var_Param_906:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_906:

push rax

push 2
Gen_Var_Bound_907:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_907:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_908:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_904:

jmp Lexit_902
Lelse_901:
Gen_Const_903:
mov rax, const_tbl+2
end_Gen_Const_903:

Lexit_902:
end_Gen_If_900:

jmp Lexit_898
Lelse_897:
Gen_Const_899:
mov rax, const_tbl+2
end_Gen_Const_899:

Lexit_898:
end_Gen_If_896:
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_874
Gen_If_917:
Gen_Applic_957:

push SOB_NIL_ADDRESS
Gen_Var_Param_958:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_958:

push rax

push 1
Gen_Var_Bound_959:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 4)]
end_Gen_Var_Bound_959:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_960:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_957:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_918
Gen_If_921:
Gen_Applic_953:

push SOB_NIL_ADDRESS
Gen_Var_Param_954:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_954:

push rax

push 1
Gen_Var_Bound_955:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 4)]
end_Gen_Var_Bound_955:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_956:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_953:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_922
Gen_If_925:
Gen_Applic_941:

push SOB_NIL_ADDRESS
Gen_Applic_942:

push SOB_NIL_ADDRESS
Gen_Var_Param_943:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_943:

push rax

push 1
Gen_Var_Bound_944:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 8)]
end_Gen_Var_Bound_944:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_945:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_942:

push rax
Gen_Applic_946:

push SOB_NIL_ADDRESS
Gen_Var_Param_947:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_947:

push rax

push 1
Gen_Var_Bound_948:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 8)]
end_Gen_Var_Bound_948:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_949:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_946:

push rax

push 2
Gen_Box_Get_950:
Gen_Var_Bound_951:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_951:

mov rax, qword [rax]
end_Gen_Box_Get_950:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_952:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_941:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_926
Gen_Applic_929:

push SOB_NIL_ADDRESS
Gen_Applic_930:

push SOB_NIL_ADDRESS
Gen_Var_Param_931:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_931:

push rax

push 1
Gen_Var_Bound_932:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 9)]
end_Gen_Var_Bound_932:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_933:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_930:

push rax
Gen_Applic_934:

push SOB_NIL_ADDRESS
Gen_Var_Param_935:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_935:

push rax

push 1
Gen_Var_Bound_936:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 9)]
end_Gen_Var_Bound_936:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_937:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_934:

push rax

push 2
Gen_Box_Get_938:
Gen_Var_Bound_939:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_939:

mov rax, qword [rax]
end_Gen_Box_Get_938:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_940:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_929:

jmp Lexit_927
Lelse_926:
Gen_Const_928:
mov rax, const_tbl+2
end_Gen_Const_928:

Lexit_927:
end_Gen_If_925:

jmp Lexit_923
Lelse_922:
Gen_Const_924:
mov rax, const_tbl+2
end_Gen_Const_924:

Lexit_923:
end_Gen_If_921:

jmp Lexit_919
Lelse_918:
Gen_Const_920:
mov rax, const_tbl+2
end_Gen_Const_920:

Lexit_919:
end_Gen_If_917:
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_874
Gen_If_961:
Gen_Applic_984:

push SOB_NIL_ADDRESS
Gen_Var_Param_985:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_985:

push rax

push 1
Gen_Var_Bound_986:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 5)]
end_Gen_Var_Bound_986:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_987:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_984:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_962
Gen_If_965:
Gen_Applic_980:

push SOB_NIL_ADDRESS
Gen_Var_Param_981:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_981:

push rax

push 1
Gen_Var_Bound_982:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 5)]
end_Gen_Var_Bound_982:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_983:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_980:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_966
Gen_Applic_969:

push SOB_NIL_ADDRESS
Gen_Applic_970:

push SOB_NIL_ADDRESS
Gen_Var_Param_971:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_971:

push rax

push 1
Gen_Var_Bound_972:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 10)]
end_Gen_Var_Bound_972:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_973:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_970:

push rax
Gen_Applic_974:

push SOB_NIL_ADDRESS
Gen_Var_Param_975:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_975:

push rax

push 1
Gen_Var_Bound_976:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 10)]
end_Gen_Var_Bound_976:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_977:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_974:

push rax

push 2
Gen_Var_Bound_978:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_978:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_979:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_969:

jmp Lexit_967
Lelse_966:
Gen_Const_968:
mov rax, const_tbl+2
end_Gen_Const_968:

Lexit_967:
end_Gen_If_965:

jmp Lexit_963
Lelse_962:
Gen_Const_964:
mov rax, const_tbl+2
end_Gen_Const_964:

Lexit_963:
end_Gen_If_961:
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_874
Gen_If_988:
Gen_Applic_1012:

push SOB_NIL_ADDRESS
Gen_Var_Param_1013:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1013:

push rax

push 1
Gen_Var_Bound_1014:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 6)]
end_Gen_Var_Bound_1014:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1015:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1012:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_989
Gen_If_992:
Gen_Applic_1008:

push SOB_NIL_ADDRESS
Gen_Var_Param_1009:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1009:

push rax

push 1
Gen_Var_Bound_1010:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 6)]
end_Gen_Var_Bound_1010:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1011:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1008:

cmp rax, SOB_FALSE_ADDRESS
je Lelse_993
Gen_Applic_996:

push SOB_NIL_ADDRESS
Gen_Applic_997:

push SOB_NIL_ADDRESS
Gen_Var_Param_998:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_998:

push rax

push 1
Gen_Var_Bound_999:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_999:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1000:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_997:

push rax
Gen_Applic_1001:

push SOB_NIL_ADDRESS
Gen_Var_Param_1002:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1002:

push rax

push 1
Gen_Var_Bound_1003:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_1003:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1004:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1001:

push rax

push 2
Gen_Box_Get_1005:
Gen_Var_Bound_1006:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 0)]
end_Gen_Var_Bound_1006:

mov rax, qword [rax]
end_Gen_Box_Get_1005:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1007:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_996:

jmp Lexit_994
Lelse_993:
Gen_Const_995:
mov rax, const_tbl+2
end_Gen_Const_995:

Lexit_994:
end_Gen_If_992:

jmp Lexit_990
Lelse_989:
Gen_Const_991:
mov rax, const_tbl+2
end_Gen_Const_991:

Lexit_990:
end_Gen_If_988:
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_874
Gen_ApplicTP_1016:

push SOB_NIL_ADDRESS
Gen_Var_Param_1017:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1017:

push rax
Gen_Var_Param_1018:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1018:

push rax

push 2
Gen_Var_Bound_1019:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 1)]
mov rax, qword[rax + (8 * 7)]
end_Gen_Var_Bound_1019:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_1020:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_1016:

Lexit_874:
end_Gen_Or_873:

    leave
    ret
  Lcont_871:
  
end_Gen_Lambda_Simple_867:

push rax
Gen_Var_Param_866:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_866:

pop qword [rax]
mov rax, SOB_VOID_ADDRESS
end_Gen_Box_get_865:

Gen_Box_Get_1021:
Gen_Var_Param_1022:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1022:

mov rax, qword [rax]
end_Gen_Box_Get_1021:

end_Gen_Seq_864:

end_Gen_Seq_860:

    leave
    ret
  Lcont_858:
  
end_Gen_Lambda_Simple_854:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_1023:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 6                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_852:

    leave
    ret
  Lcont_850:
  
end_Gen_Lambda_Simple_846:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1024:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_834:

mov qword [fvar_tbl+(41*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_833:

	call write_sob_if_not_void

Gen_Def_Var_Free_1025:
Gen_Lambda_Simple_1026:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 8                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_1031 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_1027:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 0
  jle loop_1027
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_1028:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_1028
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_1031:
  MAKE_CLOSURE(rax, rbx, Lcode_1029)
  jmp Lcont_1030
  Lcode_1029:
    push rbp
    mov rbp, rsp
    Gen_Seq_1032:
Gen_Set_Var_Param_1033:
Gen_Box_1034:
Gen_Var_Param_1035:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1035:

MALLOC r10, 8
mov qword[r10], rax
mov rax, r10
end_Gen_Box_1034:

mov qword [rbp + 8 * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Set_Var_Param_1033:

Gen_Seq_1036:
Gen_Box_get_1037:
Gen_Applic_1039:

push SOB_NIL_ADDRESS
Gen_Const_1040:
mov rax, const_tbl+34
end_Gen_Const_1040:

push rax
Gen_Box_Get_1041:
Gen_Var_Param_1042:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1042:

mov rax, qword [rax]
end_Gen_Box_Get_1041:

push rax

push 2
Gen_Var_Free_1043:
mov rax, qword [fvar_tbl+(17*8)]
end_Gen_Var_Free_1043:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1044:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1039:

push rax
Gen_Var_Param_1038:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1038:

pop qword [rax]
mov rax, SOB_VOID_ADDRESS
end_Gen_Box_get_1037:

Gen_ApplicTP_1045:

push SOB_NIL_ADDRESS
Gen_Applic_1046:

push SOB_NIL_ADDRESS
Gen_Applic_1047:

push SOB_NIL_ADDRESS
Gen_Applic_1048:

push SOB_NIL_ADDRESS
Gen_Applic_1049:

push SOB_NIL_ADDRESS
Gen_Applic_1050:

push SOB_NIL_ADDRESS
Gen_Applic_1051:

push SOB_NIL_ADDRESS
Gen_Applic_1052:

push SOB_NIL_ADDRESS
Gen_Var_Param_1053:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1053:

push rax

push 1
Gen_Var_Free_1054:
mov rax, qword [fvar_tbl+(40*8)]
end_Gen_Var_Free_1054:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1055:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1052:

push rax
Gen_Lambda_Simple_1056:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_1061 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_1057:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_1057
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_1058:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_1058
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_1061:
  MAKE_CLOSURE(rax, rbx, Lcode_1059)
  jmp Lcont_1060
  Lcode_1059:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_1062:

push SOB_NIL_ADDRESS
Gen_Var_Param_1063:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1063:

push rax
Gen_Box_Get_1064:
Gen_Var_Bound_1065:
mov rax, qword[rbp + (8 * 2)]
mov rax, qword[rax + (8 * 0)]
mov rax, qword[rax + (8 * 1)]
end_Gen_Var_Bound_1065:

mov rax, qword [rax]
end_Gen_Box_Get_1064:

push rax

push 2
Gen_Var_Free_1066:
mov rax, qword [fvar_tbl+(12*8)]
end_Gen_Var_Free_1066:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_1067:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_1062:

    leave
    ret
  Lcont_1060:
  
end_Gen_Lambda_Simple_1056:

push rax

push 2
Gen_Var_Free_1068:
mov rax, qword [fvar_tbl+(29*8)]
end_Gen_Var_Free_1068:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1069:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1051:

push rax
Gen_Const_1070:
mov rax, const_tbl+1
end_Gen_Const_1070:

push rax
Gen_Lambda_Simple_1071:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_1076 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_1072:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_1072
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_1073:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_1073
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_1076:
  MAKE_CLOSURE(rax, rbx, Lcode_1074)
  jmp Lcont_1075
  Lcode_1074:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_1077:

push SOB_NIL_ADDRESS
Gen_Applic_1078:

push SOB_NIL_ADDRESS
Gen_Var_Param_1079:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1079:

push rax

push 1
Gen_Var_Free_1080:
mov rax, qword [fvar_tbl+(33*8)]
end_Gen_Var_Free_1080:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1081:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1078:

push rax
Gen_Var_Param_1082:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1082:

push rax

push 2
Gen_Var_Free_1083:
mov rax, qword [fvar_tbl+(32*8)]
end_Gen_Var_Free_1083:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_1084:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_1077:

    leave
    ret
  Lcont_1075:
  
end_Gen_Lambda_Simple_1071:

push rax

push 3
Gen_Var_Free_1085:
mov rax, qword [fvar_tbl+(30*8)]
end_Gen_Var_Free_1085:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1086:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1050:

push rax
Gen_Lambda_Simple_1087:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_1092 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_1088:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_1088
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_1089:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_1089
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_1092:
  MAKE_CLOSURE(rax, rbx, Lcode_1090)
  jmp Lcont_1091
  Lcode_1090:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_1093:

push SOB_NIL_ADDRESS
Gen_Applic_1094:

push SOB_NIL_ADDRESS
Gen_Var_Param_1095:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1095:

push rax

push 1
Gen_Var_Free_1096:
mov rax, qword [fvar_tbl+(33*8)]
end_Gen_Var_Free_1096:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1097:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1094:

push rax
Gen_Var_Free_1098:
mov rax, qword [fvar_tbl+(40*8)]
end_Gen_Var_Free_1098:

push rax

push 2
Gen_Var_Free_1099:
mov rax, qword [fvar_tbl+(28*8)]
end_Gen_Var_Free_1099:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_1100:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 7                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_1093:

    leave
    ret
  Lcont_1091:
  
end_Gen_Lambda_Simple_1087:

push rax

push 2
Gen_Var_Free_1101:
mov rax, qword [fvar_tbl+(29*8)]
end_Gen_Var_Free_1101:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1102:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1049:

push rax
Gen_Lambda_Simple_1103:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_1108 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_1104:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_1104
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_1105:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_1105
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_1108:
  MAKE_CLOSURE(rax, rbx, Lcode_1106)
  jmp Lcont_1107
  Lcode_1106:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_1109:

push SOB_NIL_ADDRESS
Gen_Var_Param_1110:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1110:

push rax
Gen_Const_1111:
mov rax, const_tbl+1
end_Gen_Const_1111:

push rax
Gen_Lambda_Simple_1112:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 24                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_1117 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_1113:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 2
  jle loop_1113
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_1114:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_1114
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_1117:
  MAKE_CLOSURE(rax, rbx, Lcode_1115)
  jmp Lcont_1116
  Lcode_1115:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_1118:

push SOB_NIL_ADDRESS
Gen_Const_1119:
mov rax, const_tbl+1
end_Gen_Const_1119:

push rax
Gen_Const_1120:
mov rax, const_tbl+56
end_Gen_Const_1120:

push rax
Gen_Var_Param_1121:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1121:

push rax
Gen_Var_Param_1122:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1122:

push rax

push 4
Gen_Var_Free_1123:
mov rax, qword [fvar_tbl+(43*8)]
end_Gen_Var_Free_1123:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_1124:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 9                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_1118:

    leave
    ret
  Lcont_1116:
  
end_Gen_Lambda_Simple_1112:

push rax

push 3
Gen_Var_Free_1125:
mov rax, qword [fvar_tbl+(31*8)]
end_Gen_Var_Free_1125:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_1126:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 8                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_1109:

    leave
    ret
  Lcont_1107:
  
end_Gen_Lambda_Simple_1103:

push rax

push 2
Gen_Var_Free_1127:
mov rax, qword [fvar_tbl+(29*8)]
end_Gen_Var_Free_1127:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1128:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1048:

push rax
Gen_Lambda_Simple_1129:
; allocate ExtEnv to be of size |Env| + 1
  
  mov r9, 16                          ; r9 holds the depth of the env
  MALLOC rbx, r9                ; for dummy frame
  mov qword[rbx], SOB_NIL_ADDRESS
  cmp r9, 8                           ; if first lambda -> skip the old env copy
  je first_lambda_1134 
  MALLOC rbx, r9                      ; rbx now holds ExtEnv
  mov rdx, qword[rbp + 8*2]           ; rdx now points to the old env
  mov r8, 0                           ; r8 = i 
  mov r9, 1                           ; r9 = j
  
  loop_1130:                                  ; loop ExtEnv[i+1] = Env[i]
  mov r10, qword[rdx + 8*r8]
  mov qword[rbx + 8*r9], r10
  inc r8
  inc r9
  cmp r9, 1
  jle loop_1130
  mov r8, 0
  mov rcx, qword[rbp + 8*3]            ; rcx now holds the number of the params         
  imul rcx, rcx, 8
  MALLOC rdx, rcx                      ; rdx now holds array for the params                
  move_params_loop_1131:  
  mov r9, qword[rbp + 8*(4+r8)]
  mov qword[rdx + r8*8], r9             ; rdx[i] = Param-i
  inc r8
  cmp r8, qword[rbp + 8*3]
  jle move_params_loop_1131
  mov qword[rbx + 0], rdx              ; ExtEnv[0] = param_list
  first_lambda_1134:
  MAKE_CLOSURE(rax, rbx, Lcode_1132)
  jmp Lcont_1133
  Lcode_1132:
    push rbp
    mov rbp, rsp
    Gen_ApplicTP_1135:

push SOB_NIL_ADDRESS
Gen_Var_Param_1136:
 mov rax, qword[rbp + 8 * (4 + 0)]
end_Gen_Var_Param_1136:

push rax

push 1
Gen_Var_Free_1137:
mov rax, qword [fvar_tbl+(35*8)]
end_Gen_Var_Free_1137:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_1138:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 6                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_1135:

    leave
    ret
  Lcont_1133:
  
end_Gen_Lambda_Simple_1129:

push rax

push 2
Gen_Var_Free_1139:
mov rax, qword [fvar_tbl+(29*8)]
end_Gen_Var_Free_1139:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1140:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1047:

push rax
Gen_Const_1141:
mov rax, const_tbl+34
end_Gen_Const_1141:

push rax
Gen_Var_Free_1142:
mov rax, qword [fvar_tbl+(20*8)]
end_Gen_Var_Free_1142:

push rax

push 3
Gen_Var_Free_1143:
mov rax, qword [fvar_tbl+(31*8)]
end_Gen_Var_Free_1143:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1144:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1046:

push rax
Gen_Applic_1145:

push SOB_NIL_ADDRESS
Gen_Box_Get_1146:
Gen_Var_Param_1147:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1147:

mov rax, qword [rax]
end_Gen_Box_Get_1146:

push rax
Gen_Box_Get_1148:
Gen_Var_Param_1149:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1149:

mov rax, qword [rax]
end_Gen_Box_Get_1148:

push rax
Gen_Box_Get_1150:
Gen_Var_Param_1151:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1151:

mov rax, qword [rax]
end_Gen_Box_Get_1150:

push rax

push 3
Gen_Var_Free_1152:
mov rax, qword [fvar_tbl+(17*8)]
end_Gen_Var_Free_1152:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1153:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1145:

push rax
Gen_Applic_1154:

push SOB_NIL_ADDRESS
Gen_Box_Get_1155:
Gen_Var_Param_1156:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1156:

mov rax, qword [rax]
end_Gen_Box_Get_1155:

push rax
Gen_Box_Get_1157:
Gen_Var_Param_1158:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1158:

mov rax, qword [rax]
end_Gen_Box_Get_1157:

push rax

push 2
Gen_Var_Free_1159:
mov rax, qword [fvar_tbl+(20*8)]
end_Gen_Var_Free_1159:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1160:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1154:

push rax
Gen_Applic_1161:

push SOB_NIL_ADDRESS
Gen_Box_Get_1162:
Gen_Var_Param_1163:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1163:

mov rax, qword [rax]
end_Gen_Box_Get_1162:

push rax
Gen_Box_Get_1164:
Gen_Var_Param_1165:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1165:

mov rax, qword [rax]
end_Gen_Box_Get_1164:

push rax

push 2
Gen_Var_Free_1166:
mov rax, qword [fvar_tbl+(18*8)]
end_Gen_Var_Free_1166:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1167:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1161:

push rax
Gen_Box_Get_1168:
Gen_Var_Param_1169:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1169:

mov rax, qword [rax]
end_Gen_Box_Get_1168:

push rax
Gen_Box_Get_1170:
Gen_Var_Param_1171:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1171:

mov rax, qword [rax]
end_Gen_Box_Get_1170:

push rax
Gen_Applic_1172:

push SOB_NIL_ADDRESS
Gen_Applic_1173:

push SOB_NIL_ADDRESS
Gen_Const_1174:
mov rax, const_tbl+34
end_Gen_Const_1174:

push rax
Gen_Box_Get_1175:
Gen_Var_Param_1176:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1176:

mov rax, qword [rax]
end_Gen_Box_Get_1175:

push rax

push 2
Gen_Var_Free_1177:
mov rax, qword [fvar_tbl+(19*8)]
end_Gen_Var_Free_1177:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1178:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1173:

push rax
Gen_Box_Get_1179:
Gen_Var_Param_1180:
 mov rax, qword[rbp + 8 * (4 + 1)]
end_Gen_Var_Param_1180:

mov rax, qword [rax]
end_Gen_Box_Get_1179:

push rax

push 2
Gen_Var_Free_1181:
mov rax, qword [fvar_tbl+(19*8)]
end_Gen_Var_Free_1181:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1182:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1172:

push rax

push 7
Gen_Var_Free_1183:
mov rax, qword [fvar_tbl+(18*8)]
end_Gen_Var_Free_1183:

               mov bl, byte [rax]   
               cmp bl, T_CLOSURE    
               jne error_exit   
               push qword[rax+1] ; push env   
               push qword[rbp + 8]  ; old ret addr    
              debug_1184:
               mov r11, [rbp]    
               mov r12, PARAM_COUNT   
               SHIFT_FRAME 12                                 
               add r12, 5
               shl r12, 3
               add rsp, r12
               mov rbp, r11
               jmp [rax + 9]
               
end_Gen_ApplicTP_1045:

end_Gen_Seq_1036:

end_Gen_Seq_1032:

    leave
    ret
  Lcont_1030:
  
end_Gen_Lambda_Simple_1026:

mov qword [fvar_tbl+(42*8)], rax
mov rax, SOB_VOID_ADDRESS
end_Gen_Def_Var_Free_1025:

	call write_sob_if_not_void

Gen_Applic_1185:

push SOB_NIL_ADDRESS
Gen_Const_1186:
mov rax, const_tbl+25
end_Gen_Const_1186:

push rax
Gen_Const_1187:
mov rax, const_tbl+6
end_Gen_Const_1187:

push rax

push 2
Gen_Var_Free_1188:
mov rax, qword [fvar_tbl+(42*8)]
end_Gen_Var_Free_1188:

               mov bl, byte [rax]
               cmp bl, T_CLOSURE
               jne error_exit
               push qword[rax+1] ; push env
               call [rax+9]      ; call closure
               add rsp, 8*1      ; pop env
               debug_1189:
               pop rbx           ; pop arg count
               inc rbx           ; include magic
               shl rbx, 3        ; rbx = rbx * 8
               add rsp, rbx      ; pop args
end_Gen_Applic_1185:

	call write_sob_if_not_void

	mov rax, 0
	add rsp, 4*8
	pop rbp
	ret

is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

    cmp rcx, 0
    je .end
	
.loop:
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    loop .loop
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret


; ------------ my procedures -------------

proc_car:                       ; we assume the input is correct
    push rbp
    mov rbp, rsp

    mov r8, PVAR(0)           ; r8 holds the proper list
    mov rax, GET_CAR(r8)
    jmp .return

.return:
    leave
    ret


proc_cdr:                       ; we assume the input is correct
    push rbp
    mov rbp, rsp

    mov r8, PVAR(0)           ; r8 holds the proper list
    mov rax, GET_CDR(r8)
    jmp .return

.return:
    leave
    ret


proc_cons:
    push rbp
    mov rbp, rsp

    mov r8, PVAR(1)             ; r8 holds cdr
    mov r9, PVAR(0)             ; r9 holds car
    MAKE_PAIR(rax, r9, r8)
    jmp .return

.return:
    leave
    ret



proc_set_car:
    push rbp
    mov rbp, rsp

    mov r8, PVAR(0)             ; r8 holds the pair to be changed
    lea r8, [r8 + 1]
    mov r9, PVAR(1)            ; r9 hold the new car
    mov qword[r8], r9
    mov rax, SOB_VOID_ADDRESS
    jmp .return

.return:
    leave
    ret


proc_set_cdr:
    push rbp
    mov rbp, rsp

    mov r8, PVAR(0)             ; r8 holds the pair to be changed
    lea r8, [r8 + 9]
    mov r9, PVAR(1)            ; r9 hold the new cdr
    mov qword[r8], r9
    mov rax, SOB_VOID_ADDRESS
    jmp .return

.return:
    leave
    ret



proc_apply:
    push rbp
    mov rbp, rsp

    push SOB_NIL_ADDRESS        ; push magic
    mov r15, PARAM_COUNT
    dec r15
    mov rsi, 1                  ; rsi will hold the number of SOBs in the pair
    mov r14, PVAR(r15)          ; r14 holds the pair 
    mov bl, byte[r14]
    cmp bl, T_NIL     ; if we got to the NIL SOB of the pair
    je .empty
    
    
.get_to_nil:
    mov r13, GET_CAR(r14)
    mov r9, GET_CDR(r14)
    mov bl, byte[r9]
    cmp bl, T_NIL     ; if we got to the NIL SOB of the pair
    je .get_all_params_loop
    inc rsi
    mov r13, r14
    mov r14, GET_CDR(r13)
    jmp .get_to_nil

.empty:
    push SOB_NIL_ADDRESS

.get_all_params_loop:
    mov r8, rsi
.push_loop:
    mov r14, PVAR(r15)
    cmp r8, 0
    je .push_next
    mov r9, 1
.inside_loop:
    cmp r9, r8
    je .yes
    mov r13, r14
    mov r14, GET_CDR(r13)
    inc r9
    jmp .inside_loop
.yes:
    cmp r14, SOB_NIL_ADDRESS
    je .next
    mov r13, GET_CAR(r14)
    push r13
.next:
    dec r8
    jmp .push_loop

.push_next:
    
.finish_loop:
    dec r15
    cmp r15, 0
    je .finish
    mov r12, PVAR(r15)
    push r12
    jmp .finish_loop
.finish:
    mov r12, PARAM_COUNT
    add r12, rsi                ; rsi holds new param count
    dec r12
    dec r12
    push r12
    add r12, 5
.debug:
    mov rcx, qword[rbp + 8*4] ;rcx holds proc  
    push qword[rcx + 1] ; push proc env   
    push qword[rbp + 8]  ; old ret addr    
    mov r8, qword[rbp + 8*4]     
    mov r11, [rbp] 
    mov r10, PARAM_COUNT     
    SHIFT_FRAME(r12)
    add r10, 5
    shl r10, 3
    add rsp, r10 
    mov rbp, r11
    jmp [r8 + 9]
    
    
    
